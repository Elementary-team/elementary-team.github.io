{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flutter Elementary","text":""},{"location":"#_1","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>Elementary is a simple and reliable way to build applications with MVVM in Flutter. Benefits of using Elementary include:</p> <ul> <li>Maximum Flutter-like: You don't need to spend a lot of time learning the library if you are already familiar with the standard Flutter approaches.</li> <li>Code separation by responsibility: Splitting code into different layers reduces coupling, making the code simpler and more readable.</li> <li>High testability: All layers, from widgets to business logic, are highly testable.</li> <li>Team efficiency: It boosts speed for teams consisting of more than one person, due to the easy sharing of independent task parts among team members.</li> </ul>"},{"location":"#packages","title":"Packages","text":"<p>Apart from the main package, elementary includes a bunch of supportive. You can find the actual status of them below.</p> Package Version elementary elementary_helper elementary_test elementary_cli"},{"location":"#environment","title":"Environment","text":"<p>To reduce the amount of boilerplate and manual work, Elementary offers a few tools:</p> <ul> <li>elementary_cli: A command line utility that helps with boilerplate generation.</li> <li>Plugin for IntelliJ: A plugin for the IntelliJ IDE family, based on elementary_cli.</li> <li>Plugin for VSCode: A plugin for VSCode, based on elementary_cli.</li> <li>elementary brick: A command line utility that helps with boilerplate generation, based on Mason.</li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"about/#maintainer","title":"Maintainer","text":"<p> <p>Mikhail Zotyev</p> </p>"},{"location":"about/#contributors-thanks","title":"Contributors thanks","text":"<p>Big thanks to all these people, who put their effort into helping the project.</p> <p> </p> <p>Special thanks to:</p> <p>Dmitry Krutskikh, Konoshenko Vlad, and  Denis Grafov for the early adoption and the first production feedback;</p> <p>Alex Bukin for IDE plugins;</p> <p>All members of the Surf Flutter Team for actively using and providing feedback.</p>"},{"location":"about/#sponsorship","title":"Sponsorship","text":"<p>Special sponsor of the project:</p> <p> </p>"},{"location":"about/#contacts","title":"Contacts","text":"<p>For all questions regarding sponsorship/collaboration connect with Mikhail Zotyev.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2021 Mikhail Zotyev</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"libs/elementary/intro/","title":"Intro","text":""},{"location":"libs/elementary/intro/#_1","title":"Intro","text":""},{"location":"libs/elementary/intro/#_2","title":"Intro","text":""},{"location":"libs/elementary/intro/#what-this-library-is","title":"What this library is","text":"<p>This is an implementation of the Model-View-ViewModel (MVVM) pattern for Flutter applications. </p> <p>The current implementation follows the rules of the MVVM architecture pattern, is inspired by the internal implementation of Flutter, and incorporates positive aspects from the Business Logic Component architecture pattern and Clean Architecture principles.</p>"},{"location":"libs/elementary/intro/#benefits-of-using","title":"Benefits of using","text":"<ul> <li> <p>Clear Layer Separation:  The code is divided into layers with distinct responsibilities, making it easy even for newbie developers to get started with the library.</p> </li> <li> <p>High Independence Between Layers:  This decoupling simplifies testing and maintenance. It also allows team members to work independently on different layers while developing a single feature, which leads to decreasing time-to-feature.</p> </li> <li> <p>Ease of Testing: The easier it is to test, the more cases are covered. This approach supports various test types, such as unit, widget, golden, and end-to-end tests. Writing tests with Elementary requires minimal additional effort, providing strong motivation to do it.</p> </li> <li> <p>Fully Declarative Widget Layer: The widget layer remains purely declarative, devoid of any logic. This aligns with Flutter's focus on declarative UI, with other layers handling the logic.</p> </li> <li> <p>Efficient rebuilds: Flutter\u2019s optimized rebuild strategies are crucial for performance. Elementary uses the observer pattern for properties, minimizing unnecessary rebuilds and enhancing application efficiency.</p> </li> </ul>"},{"location":"libs/elementary/model/","title":"ElementaryModel","text":"<p>For the MVVM concept Model classes are:</p> <p>non-visual classes that encapsulate the app's data. Therefore, the model can be thought of as representing the app's domain model, which usually includes a data model along with business and validation logic. Examples of model objects include data transfer objects (DTOs), Plain Old CLR Objects (POCOs), and generated entity and proxy objects. They are typically used in conjunction with services or repositories that encapsulate data access and caching.</p> <p>So based on that, <code>ElementaryModel</code> is the single point of interaction with business logic for the related <code>WidgetModel</code>. It encapsulates all required business logic for the <code>WidgetModel</code> and provides it as a contract. Summarizing it, for every <code>WidgetModel</code>, a corresponding <code>ElementaryModel</code> is the single business logic dependency. Apart from that, there is no other requirement for the <code>ElementaryModel</code> implementation, and internally it can be built as you prefer.</p>"},{"location":"libs/elementary/overview/","title":"Overview","text":""},{"location":"libs/elementary/overview/#general-overview","title":"General Overview","text":"<p>A good way to demonstrate the library's functionality without technical details is with this scheme: in the WidgetModel, we determine what to display to the user and manage the business processes running behind the scenes.</p> <p></p>"},{"location":"libs/elementary/overview/#technical-overview","title":"Technical Overview","text":"<p>Elementary follows classical MVVM layering, comprising the View, ViewModel, and Model layers. Each layer is represented by a specific entity: <code>ElementaryWidget</code> for the View layer, <code>WidgetModel</code> for the ViewModel layer, and <code>ElementaryModel</code> for the Model layer.</p> <p>To naturally integrate this chain of entities into the Flutter trees, the following decisions were made:</p> <ul> <li>An <code>ElementaryWidget</code>, like all other widgets, is simply a configuration and an immutable description of a part of the user interface.</li> <li>An <code>ElementaryWidget</code> is a component widget (represented by a ComponentElement), meaning it describes its subtree as a combination of other widgets.</li> <li>A representation of an <code>ElementaryWidget</code> in the Element tree is a special Element called <code>Elementary</code>.</li> <li><code>Elementary</code> creates a <code>WidgetModel</code> using a factory method from <code>ElementaryWidget</code> and then stores and manages it.</li> <li>The lifecycle of the <code>WidgetModel</code> is connected to the <code>Elementary</code> lifecycle, as indicated in the previous statement.</li> <li>A <code>WidgetModel</code> depends on an <code>ElementaryModel</code>, stores it, and manages its lifecycle.</li> <li>When a subtree needs to be described, <code>Elementary</code> delegates to the <code>build</code> method of <code>ElementaryWidget</code>, providing the <code>WidgetModel</code>. This represents <code>UI=f(State)</code> in the form <code>subtree=build(WM)</code>.</li> </ul> <p>The following diagram illustrates how these components work when an ElementaryWidget is inserted into the tree:</p> <p></p>"},{"location":"libs/elementary/recommendations/","title":"Recommendations","text":""},{"location":"libs/elementary/recommendations/#how-to-test","title":"How to test","text":"<p>Since all layers are well-separated from each other, they are easy to test with many options available.</p> <ul> <li>The Model layer contains only business logic, so use unit tests for it.</li> <li>Use widget-model tests from the elementary_test library for <code>WidgetModel</code>s. These tests are also unit tests but with ready-to-use controls for emulating the lifecycle.</li> <li>Use widget and golden tests for the Widget layer. This should be easy because you don't need to mock all internal things, only the values from the <code>WidgetModel</code> contract.</li> <li>Use integration tests to check the workflow together.</li> </ul>"},{"location":"libs/elementary/recommendations/#utils","title":"Utils","text":"<p>There are many helpers available for Elementary. Check elementary_helper to find them. Their purpose is to make using Elementary smooth. However, as mentioned, you can use them if you prefer, but you are not obligated to if you prefer something else.</p>"},{"location":"libs/elementary/widget-model/","title":"Widget Model","text":"<p>In the MVVM concept, the ViewModel is the workhorse: it connects the View and Model, orchestrates business processes, and contains presentation logic. This is why <code>WidgetModel</code> is the key part of the responsibility chain in Elementary.</p>"},{"location":"libs/elementary/widget-model/#widgetmodels-properties","title":"WidgetModel's properties","text":"<p>Flutter has many internal optimizations and can be highly effective, but there\u2019s no magic to make every code efficient; we also need to care about performance. One aspect that everyone encounters in every application is rebuilds. It is crucial to make them efficient. The most efficient approach is to rebuild only the parts that need to change.</p> <p>At the same time, MVVM is convenient to use when there is binding between UI parts and ViewModel properties.</p> <p>Based on this, Elementary aims to use properties that follow the Observer design pattern paradigm. In this case, a property acts as the subject (publisher). In the widget layer, we use a builder subscribed to the property, functioning as the observer (dependent/subscriber).</p> <p></p> <p>There\u2019s no mandatory requirement for which implementation of this pattern to use \u2014 it can be ChangeNotifiers, Streams, or any other preferred method. However, for your convenience, a few implementations are provided with Elementary. To find them, check the support library.</p> <p>Properties that are not intended to change or initiate a visual update can simply be getters or fields.</p>"},{"location":"libs/elementary/widget-model/#widgetmodels-lifecycle","title":"WidgetModel's lifecycle","text":"<p>As mentioned earlier, the <code>WidgetModel</code> has its lifecycle synchronized with the lifecycle of the <code>Element</code> to which it belongs. If you're familiar with the lifecycle of State in a StatefulWidget, it will be easy for you \u2014 they are quite similar. The one significant difference is that the methods <code>didUpdateWidget</code> and <code>didChangeDependencies</code> do not automatically initiate a rebuild of the subtree. The reason for this is that Elementary aims to avoid unnecessary rebuilds, and with the property-publisher approach, you can efficiently rebuild only the parts of the UI that require updates. So, the sole purpose of these methods is to notify you that these events occur, and the final decision on what and how to rebuild is up to you.</p>"},{"location":"libs/elementary/widget-model/#lifecycle-methods","title":"Lifecycle methods:","text":"<ul> <li> <p><code>initWidgetModel</code> is called only once in the lifecycle of the WidgetModel in the beginning (before the first build). This method can be used to initiate a starting state of the <code>WidgetModel</code>.</p> </li> <li> <p><code>didUpdateWidget</code> is called whenever the corresponding <code>ElementaryWidget</code> instance in the tree has been updated. A common case is when the rebuild comes from the top of the tree. This method is a good place to actualize the state of the <code>WidgetModel</code> based on the new configuration of the widget. This does not lead to a rebuild of the subtree. Please set new values to publishers for rebuilding specific parts of the UI.</p> </li> <li> <p><code>didChangeDependencies</code> is called whenever the dependencies that <code>WidgetModel</code> subscribed to by BuildContext change. This does not lead to a rebuild of the subtree. Please set new values to publishers for rebuilding specific parts of the UI.</p> </li> <li> <p><code>deactivate</code> is called when the <code>WidgetModel</code> with <code>Elementary</code> is removed from the tree.</p> </li> <li> <p><code>activate</code> is called when the <code>WidgetModel</code> with <code>Elementary</code> is reinserted into the tree after being removed via deactivate.</p> </li> <li> <p><code>dispose</code> is called when the <code>WidgetModel</code> is going to be permanently destroyed.</p> </li> <li> <p><code>reassemble</code> is called whenever the application is reassembled during debugging, for example during a hot reload.</p> </li> <li> <p><code>onErrorHandle</code> is called when the <code>ElementaryModel</code> handles an error with the <code>ElementaryModel.handleError</code> method. Can be useful for general handling errors, such as showing a snack bar.</p> </li> </ul>"},{"location":"libs/elementary/widget-model/#widgetmodel-as-a-contract","title":"WidgetModel as a contract","text":"<p>It can be a good idea to use an interface for your <code>WidgetModel</code>s for the sake of code testability and to explicitly describe the contract that can be used during the subtree build by <code>ElementaryWidget</code>.</p> <pre><code>/// An interface for [ExampleScreenWidgetModel]\nabstract interface class IExampleScreenWidgetModel implements IWidgetModel {\n  /// Provides observable information about some integer value.\n  ValueListenable&lt;int&gt; get exampleProperty;\n}\n</code></pre>"},{"location":"libs/elementary/widget-model/#ompleteness-of-the-state-description","title":"\u0421ompleteness of the state description","text":"<p><code>WidgetModel</code> is the source of truth for describing the subtree. This means it should provide everything required for this build. In other words, the contract of the <code>WidgetModel</code> should be a complete abstraction of what is shown on the UI. In this case, the building subtree appears to be only a declarative description by the rule <code>UI = f(S)</code>.</p>"},{"location":"libs/elementary/widget-model/#access-to-context","title":"Access to Context","text":"<p><code>WidgetModel</code> is the only place that has access to <code>BuildContext</code> in the triad <code>ElementaryWidget-WidgetModel-ElementaryModel</code>.</p> <p>There are a few reasons for this:</p> <ul> <li><code>WidgetModel</code> has a tight bond with the <code>Elementary</code>, which is an Element (BuildContext).</li> <li><code>WidgetModel</code> contains everything relative to presentation logic and defining the current state =&gt; all updates by the context subscription should come there.</li> <li><code>ElementaryModel</code> is a business logic layer. Business logic should be pure and independent from Flutter. So BuildContext is not appropriate there.</li> <li><code>ElementaryWidget</code> should contain only a declarative description and be free from any logic. It also has the source of truth, which is <code>WidgetModel</code>.</li> </ul> <p>It is important to note that all this is relative only to the level when <code>ElementaryWidget</code> is used, and down-laying widgets might have access to context on their levels.</p>"},{"location":"libs/elementary/widget-model/#access-to-widget","title":"Access to Widget","text":"<p>Respecting the general Flutter approach, <code>ElementaryWidget</code> is an immutable configuration. <code>WidgetModel</code> has access to <code>ElementaryWidget</code> at any time. This can be useful for initiating or updating <code>WidgetModel</code>'s properties.</p> <pre><code>@override\nvoid initWidgetModel() {\n  super.initWidgetModel();\n\n  _someProperty = ValueNotifier&lt;int&gt;.value(widget.passedValue);\n}\n\n@override\nvoid didUpdateWidget(TestPageWidget oldWidget) {\n  super.didUpdateWidget(oldWidget);\n\n  if (widget.passedValue != oldWidget.passedValue) {\n    _someProperty.value = widget.passedValue;\n  }\n}\n</code></pre>"},{"location":"libs/elementary/widget-model/#showcase-example","title":"Showcase Example","text":"<p>This is a simple example showing a case with loading data from the network. While loading, we use previous data. As a property providing this data to the UI, we use <code>EntityStateNotifier</code> - a publisher with 3 base states: content, error, and loading. For more details about the implementation of this publisher, check the support library.</p> <pre><code>/// Widget Model for [ExampleScreen]\nclass ExampleWidgetModel extends WidgetModel&lt;ExampleScreen, ExampleModel&gt; implements IExampleWidgetModel {\n  final _exampleState = EntityStateNotifier&lt;ExampleEntity&gt;();\n\n  @override\n  ListenableState&lt;EntityState&lt;ExampleEntity&gt;&gt; get exampleState =&gt; _exampleState;\n\n  @override\n  void initWidgetModel() {\n    super.initWidgetModel();\n\n    _loadData();\n  }\n\n  Future&lt;void&gt; _loadData() async {\n    final previousData = _exampleState.value?.data;\n    _exampleState.loading(previousData);\n\n    try {\n      final res = await model.loadData();\n      _exampleState.content(res);\n    } on Exception catch (e) {\n      _exampleState.error(e, previousData);\n    }\n  }\n}\n\n/// An interface for [ExampleWidgetModel]\nabstract interface class IExampleWidgetModel implements IWidgetModel {\n  ListenableState&lt;EntityState&lt;ExampleEntity&gt;&gt; get exampleState;\n}\n</code></pre>"},{"location":"libs/elementary/widget/","title":"ElementaryWidget","text":""},{"location":"libs/elementary/widget/#widget-as-a-view-description","title":"Widget as a View description","text":"<p><code>ElementaryWidget</code> represents a View layer in the triad <code>ElementaryWidget-WidgetModel-ElementaryModel</code>. In the MVVM concept, views are responsible for defining the structure, layout, and appearance of what the user sees on screen.</p> <p>It is important to remember that Flutter is a declarative framework, and any Flutter widget is not a view, but a configuration/description. So, it is more accurate to say that <code>ElementaryWidget</code> is a view description, a component widget that uses other widgets to describe a composition that needs to be shown to the user. By hiding how the framework works behind the widget concept, we can simplify to equate <code>ElementaryWidget</code> with View.</p> <p>The significant difference from other composition widgets is the simplified build process. Since business logic and presentation logic are encapsulated in the Model and Widget Model, it is only left to the widget to follow the <code>UI = f(s)</code> principle and describe this UI based on the <code>WidgetModel</code> contract. Therefore, the build method doesn't have context and accepts only the <code>WidgetModel</code> contract as an argument.</p> <p>Here is an example of <code>ElementaryWidget</code>'s build method for a case of loading data from the network:</p> <pre><code>@override\nWidget build(IExampleWidgetModel wm) {\n  return Scaffold(\n    appBar: AppBar(\n      title: const Text('Example Screen'),\n    ),\n    body: EntityStateNotifierBuilder&lt;ExampleEntity&gt;(\n      listenableEntityState: wm.exampleState,\n      loadingBuilder: (_, __) =&gt; const _LoadingWidget(),\n      errorBuilder: (_, __, ___) =&gt; const _ErrorWidget(),\n      builder: (_, data) =&gt; _ContentWidget(data: data),\n    ),\n  );\n}\n</code></pre>"},{"location":"libs/elementary/widget/#widget-as-a-starting-and-updating-configuration","title":"Widget as a starting and updating configuration","text":"<p>Apart from describing a subtree, <code>ElementaryWidget</code> is a configuration. On one side, it is a configuration of the MVVM layers, meaning this widget defines a factory to be used for creating a corresponding <code>WidgetModel</code> instance. On the other side, it is a Flutter way to set and update externally defined parameters. For example, for a screen that shows detailed information about a product, it could be the product's ID. However, it can be any information defined higher up in the tree, and an update to the configuration automatically leads to a call for lifecycle methods.</p>"},{"location":"libs/elementary-helper/intro/","title":"Intro","text":""},{"location":"libs/elementary-helper/intro/#_1","title":"Intro","text":""},{"location":"libs/elementary-helper/intro/#_2","title":"Intro","text":"<p>To make Elementary easier to use, some helpers have been added. Among them are custom implementations of the observer pattern and wrappers to facilitate easier and more testable interactions with Flutter from the <code>WidgetModel</code>.</p>"},{"location":"libs/elementary-helper/publishers/","title":"Publishers","text":""},{"location":"libs/elementary-helper/publishers/#statenotifier","title":"StateNotifier","text":"<p>The behavior is similar to <code>ValueNotifier</code> but with no requirement to set an initial value. Due to this, the returned value is nullable. <code>StateNotifier</code>'s subscribers are notified whenever a state change occurs. Additionally, the subscriber is called for the first time at the moment of subscription. Use <code>accept</code> to emit a new value.</p> <pre><code>final _somePropertyWithIntegerValue = StateNotifier&lt;int&gt;();\n\nvoid someFunctionChangeValue() {\n  // do something, get new value\n  // ...............................................................\n  final newValue = _doSomething();\n  // and then change value of property\n  _somePropertyWithIntegerValue.accept(newValue);\n}\n</code></pre>"},{"location":"libs/elementary-helper/publishers/#entitystatenotifier","title":"EntityStateNotifier","text":"<p>A variant of <code>ValueNotifier</code> that uses a special <code>EntityState</code> object as the state value. <code>EntityState</code> has three states: <code>content</code>, <code>loading</code>, and <code>error</code>. All states can contain data, for cases when you want to keep previous values, such as pagination.</p> <pre><code>final _countryListState = EntityStateNotifier&lt;Iterable&lt;Country&gt;&gt;();\n\nFuture&lt;void&gt; _loadCountryList() async {\n  final previousData = _countryListState.value?.data;\n\n  // set property to loading state and use previous data for this state\n  _countryListState.loading(previousData);\n\n  try {\n    // await the result\n    final res = await model.loadCountries();\n    // set property to content state, use new data\n    _countryListState.content(res);\n  } on Exception catch (e) {\n    // set property to error state\n    _countryListState.error(e, previousData);\n  }\n}\n</code></pre>"},{"location":"libs/elementary-helper/subscribers/","title":"Subscribers","text":""},{"location":"libs/elementary-helper/subscribers/#statenotifierbuilder","title":"StateNotifierBuilder","text":"<p>The <code>StateNotifierBuilder</code> is a widget that uses a <code>StateNotifier</code> as its data source. A builder function of the <code>StateNotifierBuilder</code> must return a widget based on the current value passed.</p> <pre><code>void somewhereInTheBuildFunction() {\n  // ......\n  StateNotifierBuilder&lt;String&gt;(\n    listenableState: someListenableState,\n    builder: (ctx, value) {\n      return Text(value);\n    },\n  );\n  // ......\n}\n</code></pre>"},{"location":"libs/elementary-helper/subscribers/#entitystatenotifierbuilder","title":"EntityStateNotifierBuilder","text":"<p>The <code>EntityStateNotifierBuilder</code> is a widget that uses an <code>EntityStateNotifier</code> as its data source. Depending on the state, different builders are called: <code>errorBuilder</code> for error, <code>loadingBuilder</code> for loading, and <code>builder</code> for content.</p> <pre><code>@override\nWidget build(ICountryListWidgetModel wm) {\n  return Scaffold(\n    appBar: AppBar(\n      title: const Text('Country List'),\n    ),\n    body: EntityStateNotifierBuilder&lt;Iterable&lt;Country&gt;&gt;(\n      listenableEntityState: wm.countryListState,\n      loadingBuilder: (_, __) =&gt; const _LoadingWidget(),\n      errorBuilder: (_, __, ___) =&gt; const _ErrorWidget(),\n      builder: (_, countries) =&gt;\n          _CountryList(\n            countries: countries,\n            nameStyle: wm.countryNameStyle,\n          ),\n    ),\n  );\n}\n</code></pre>"},{"location":"libs/elementary-helper/subscribers/#doublesourcebuilder","title":"DoubleSourceBuilder","text":"<p>One of the multi-source builders, it uses two <code>ListenableState</code> objects as sources of data. The builder function is called whenever any of the sources change.</p> <pre><code>void somewhereInTheBuildFunction() {\n  // ......\n  DoubleSourceBuilder&lt;String, TextStyle&gt;(\n    firstSource: captionListenableState,\n    secondSource: captionStyleListenableState,\n    builder: (ctx, value, style) {\n      return Text(value, style: style);\n    },\n  );\n  // ......\n}\n</code></pre>"},{"location":"libs/elementary-helper/subscribers/#doublevaluelistenablebuilder","title":"DoubleValueListenableBuilder","text":"<p>One of the multi-source builders, it uses two <code>ValueListenable</code> objects as sources of data. The builder function is called whenever any of the sources change.</p> <pre><code>void somewhereInTheBuildFunction() {\n  // ......\n  DoubleValueListenableBuilder&lt;String, TextStyle&gt;(\n    firstValue: captionListenableState,\n    secondValue: captionStyleListenableState,\n    builder: (ctx, value, style) {\n      return Text(value, style: style);\n    },\n  );\n  // ......\n}\n</code></pre>"},{"location":"libs/elementary-helper/subscribers/#triplesourcebuilder","title":"TripleSourceBuilder","text":"<p>One of the multi-source builders, it uses three <code>ListenableState</code> objects as sources of data. The builder function is called whenever any of the sources change.</p> <pre><code>void somewhereInTheBuildFunction() {\n  // ......\n  TripleSourceBuilder&lt;String, int, TextStyle&gt;(\n    firstSource: captionListenableState,\n    secondSource: valueListenableState,\n    thirdSource: captionStyleListenableState,\n    builder: (ctx, title, value, style) {\n      return Text('$title: ${value ?? 0}', style: style);\n    },\n  );\n  // ......\n}\n</code></pre>"},{"location":"libs/elementary-helper/subscribers/#triplevaluelistenablebuilder","title":"TripleValueListenableBuilder","text":"<p>One of the multi-source builders, it uses three <code>ValueListenable</code> objects as sources of data. The builder function is called whenever any of the sources change.</p> <pre><code>void somewhereInTheBuildFunction() {\n  // ......\n  TripleSourceBuilder&lt;String, int, TextStyle&gt;(\n    firstSource: captionListenableState,\n    secondSource: valueListenableState,\n    thirdSource: captionStyleListenableState,\n    builder: (ctx, title, value, style) {\n      return Text('$title: ${value ?? 0}', style: style);\n    },\n  );\n  // ......\n}\n</code></pre>"},{"location":"libs/elementary-helper/subscribers/#multilistenerrebuilder","title":"MultiListenerRebuilder","text":"<p>A widget that rebuilds part of the UI when one of the <code>Listenable</code> objects changes. The builder function in this widget does not take any values as parameters; you need to get the values directly within the function's body.</p> <pre><code>void somewhereInTheBuildFunction() {\n  // ......\n  MultiListenerRebuilder(\n    listenableList: [\n      firstListenable,\n      secondListenable,\n      thirdListenable,\n    ],\n    builder: (ctx) {\n      final title = firstListenable.value;\n      final value = secondListenable.value;\n      final style = thirdListenable.value;\n      return Text('$title: ${value ?? 0}', style: style);\n    },\n  );\n  // ......\n}\n</code></pre>"},{"location":"libs/elementary-test/intro/","title":"Intro","text":""},{"location":"libs/elementary-test/intro/#_1","title":"Intro","text":""},{"location":"libs/elementary-test/intro/#_2","title":"Intro","text":"<p>A handy testing library for apps built with Elementary. This library offers some handy tools to test <code>WidgetModel</code> from the Elementary package.</p>"},{"location":"libs/elementary-test/overview/","title":"Overview","text":""},{"location":"libs/elementary-test/overview/#testwidgetmodel-method","title":"testWidgetModel method","text":"<p>The main testing tool is the <code>testWidgetModel</code> function, which executes a test. The parameters it requires are the name of the test, the function preparing the <code>WidgetModel</code> for testing, and the test function itself.</p>"},{"location":"libs/elementary-test/overview/#testfunction-parameter","title":"testFunction parameter","text":"<p>This is a function of the test itself. When passed the <code>WidgetModel</code>, this function describes its behavior and verifies the result. The function also uses a tester to manipulate the phases of the <code>WidgetModel</code> lifecycle and a <code>BuildContext</code> mock.</p>"},{"location":"libs/elementary-test/overview/#example","title":"Example","text":"<pre><code>void main() {\n  late TestPageModelMock model;\n  late ThemeWrapperMock theme;\n  late TextThemeMock textTheme;\n\n  TestPageWidgetModel setUpWm() {\n    textTheme = TextThemeMock();\n    when(() =&gt; textTheme.headline4).thenReturn(null);\n    theme = ThemeWrapperMock();\n    when(() =&gt; theme.getTextTheme(any())).thenReturn(textTheme);\n    model = TestPageModelMock();\n    when(() =&gt; model.value).thenReturn(0);\n    when(() =&gt; model.increment()).thenAnswer((invocation) =&gt; Future.value(1));\n\n    return TestPageWidgetModel(model, theme);\n  }\n\n  testWidgetModel&lt;TestPageWidgetModel, TestPageWidget&gt;(\n    'counterStyle should be headline4',\n    setUpWm,\n        (wm, tester, context) {\n      final style = TextStyleMock();\n      when(() =&gt; textTheme.headline4).thenReturn(style);\n\n      tester.init();\n\n      expect(wm.counterStyle, style);\n    },\n  );\n\n  testWidgetModel&lt;TestPageWidgetModel, TestPageWidget&gt;(\n    'when call increment and before get answer valueState should be loading',\n    setUpWm,\n        (wm, tester, context) async {\n      tester.init();\n\n      when(() =&gt; model.increment()).thenAnswer(\n            (invocation) =&gt; Future.delayed(\n          const Duration(milliseconds: 30),\n              () =&gt; 1,\n        ),\n      );\n\n      unawaited(wm.increment());\n\n      await Future&lt;void&gt;.delayed(\n        const Duration(milliseconds: 10),\n      );\n\n      final value = wm.valueState.value;\n\n      expect(value, isNotNull);\n      expect(value!.isLoading, isTrue);\n    },\n  );\n}\n</code></pre>"},{"location":"tutorials/qs/dependencies/","title":"Dependencies","text":""},{"location":"tutorials/qs/dependencies/#depend-on-elementary","title":"Depend on elementary","text":"<p>Run this command</p> <pre><code>flutter pub add elementary\n</code></pre> <p>or manually add dependency to your project pubspec.yaml</p> <pre><code>dependencies:\n  elementary: $actual_version\n</code></pre>"},{"location":"tutorials/qs/dependencies/#depend-on-elementary_helper","title":"Depend on elementary_helper","text":"<p>Run this command</p> <pre><code>flutter pub add elementary_helper\n</code></pre> <p>or manually add dependency to your project pubspec.yaml</p> <pre><code>dependencies:\n  elementary_helper: $actual_version\n</code></pre>"},{"location":"tutorials/qs/dependencies/#depend-on-elementary_test","title":"Depend on elementary_test","text":"<p>Run this command</p> <pre><code>flutter pub add elementary_test\n</code></pre> <p>or manually add dependency to your project pubspec.yaml</p> <pre><code>dependencies:\n  elementary_test: $actual_version\n</code></pre>"},{"location":"tutorials/qs/implementation/","title":"Implementation","text":""},{"location":"tutorials/qs/implementation/#define-the-part","title":"Define the part","text":"<p>Deside what part of the user interface you are going to work on. Choose a name that accurately describes it, you will use it when creating files.</p> <p>Tip</p> <p>You can choose any part of the UI that makes semantic sense and has its own presentation and business logic: the whole screen, a tab, even a small button. But in most common cases, it is a screen.</p>"},{"location":"tutorials/qs/implementation/#create-classes","title":"Create classes:","text":"<p>Using a chosen tool create classes for ElementaryModel, WidgetModel, ElementaryWidget.</p> Plugin for IntelliJPlugin for VSCodeElementary brickElementary cliManual creation <p>1. Choose the location where the ElementaryModel, ElementaryWidgetModel, and ElementaryWidget will be located.</p> <p>2. Open the Context Menu on that dirrectory.</p> <p>3. Choose 'New' -&gt; 'Elementary Module'.</p> <p>4. Enter the name of your module. </p> <p>Tip</p> <p>This name will be used for ElementaryModel, ElementaryWidgetModel, and ElementaryWidget. For example, if the name is \u2018example\u2019, the classes will be named ExampleModel, ExampleWidgetModel, and ExampleWidget.</p> <p>5. If you want to create a separate directory for these files inside the chosen location, check the \u2018Create subdirectory\u2019 box.</p> <p>Success</p> <p>After these steps, ElementaryModel, ElementaryWidgetModel, and ElementaryWidget are created and prepared for you.</p> <p>Bug</p> <p>IntelliJ IDEAs sometimes has a bug where created files are not displayed in the project immediately. Try collapsing and expanding the directory in the Project tab or use \u2018Open in Finder/Explorer\u2019.</p> <p>1. Choose the location where the ElementaryModel, ElementaryWidgetModel, and ElementaryWidget will be located.</p> <p>2. Open the Context Menu on that dirrectory.</p> <p>3. Select 'Generate Elementary Module'.</p> <p>4. Enter the name of your module. </p> <p>Tip</p> <p>This name will be used for ElementaryModel, ElementaryWidgetModel, and ElementaryWidget. For example, if the name is \u2018example\u2019, the classes will be named ExampleModel, ExampleWidgetModel, and ExampleWidget.</p> <p>5. If you want to create a separate directory for these files  inside chosen location, choose \u2018Yes\u2019 in the next dialog.</p> <p>Success</p> <p>After these steps, ElementaryModel, ElementaryWidgetModel, and ElementaryWidget are created and prepared for you.</p> <p>1. Run:</p> <pre><code>mason make elementary\n</code></pre> <p>2. Enter the name of your module. </p> <p>Tip</p> <p>This name will be used for ElementaryModel, ElementaryWidgetModel, and ElementaryWidget. For example, if the name is \u2018example\u2019, the classes will be named ExampleModel, ExampleWidgetModel, and ExampleWidget.</p> <p>3.  Enter a suffix for WidgetModel, for example, 'WidgetModel' or 'Wm'.</p> <p>Success</p> <p>After these steps, ElementaryModel, ElementaryWidgetModel, and ElementaryWidget are created and prepared for you.</p> <p>1. In the console, navigate to the location where you want to create ElementaryModel, ElementaryWidgetModel, and ElementaryWidget. </p> <p>Note</p> <p>Otherwise, you have to set the \u2018root path\u2019 parameter for the \u2018generate\u2019 command to define the path.</p> <p>2. Run:</p> <pre><code>elementary_tools generate module -n [name] -p [root path] -s\n</code></pre> <p>where</p> <p>[name] is the name of your module, for example, 'TestScreen',</p> <p>[root path] - path where ElementaryModel, ElementaryWidgetModel, and ElementaryWidget should be located (optional).</p> <p>Success</p> <p>After these steps, ElementaryModel, ElementaryWidgetModel, and ElementaryWidget are created and prepared for you.</p> <p>1. Choose the location where the ElementaryModel, ElementaryWidgetModel, and ElementaryWidget will be located.</p> <p>2. Create files for  ElementaryModel, ElementaryWidgetModel, and ElementaryWidget.</p> <p>3. First, create the ElementaryModel in its designated file.</p> <pre><code>import 'package:elementary/elementary.dart';\n\nclass ExampleModel extends ElementaryModel {\n    ExampleModel();\n}\n</code></pre> <p>4. Then, create the interface for WidgetModel in its designated file.</p> <pre><code>abstract interface class IExampleWidgetModel implements IWidgetModel {}\n</code></pre> <p>5. Now, create the ElementaryWidget in its designated file.</p> <pre><code>import 'package:elementary/elementary.dart';\nimport 'package:flutter/material.dart';\nimport 'example_wm.dart';\n\nclass ExampleWidget extends ElementaryWidget&lt;IExampleWidgetModel&gt; {\n  const ExampleWidget({\n    Key? key,\n    WidgetModelFactory wmFactory = defaultExampleWidgetModelFactory,\n  }) : super(wmFactory, key: key);\n\n  @override\n  Widget build(IExampleWidgetModel wm) {\n    return Placeholder();\n  }\n}\n</code></pre> <p>6. Now your widget requires a wmFactory, so you can proceed to create the WidgetModel and the default factory for it. Create it in the same file where you created the interface.</p> <pre><code>import 'package:elementary/elementary.dart';\nimport 'package:flutter/material.dart';\nimport 'example_model.dart';\nimport 'example_widget.dart';\n\nabstract interface class IExampleWidgetModel implements IWidgetModel {\n}\n\nExampleWidgetModel defaultExampleWidgetModelFactory(BuildContext context) {\n  final errorHandler = DefaultDebugErrorHandler();\n  final model = ExampleModel(errorHandler);\n  return ExampleWidgetModel(model);\n}\n\nclass ExampleWidgetModel extends WidgetModel&lt;ExampleWidget, ExampleModel&gt;\n    implements IExampleWidgetModel {\n\n  ExampleWidgetModel(ExampleModel model) : super(model);\n}\n</code></pre> <p>Success</p> <p>After these steps you can start with implementation.</p>"},{"location":"tutorials/qs/implementation/#elementarymodel","title":"ElementaryModel:","text":"<p>Open the created file to ElementaryModel and implement all the business logic in a free style. It can be a work in place with a business domain model, operating with a repository, or proxying to a responsible service, or use-case, etc.</p> <p>We'll take as a reference a simple ElementaryModel, that fetches data using a repository directly. In this model we create a method to load data. Inside the method, we catch exceptions and call <code>handleError</code> to track a problem with the error handler and notify the widget model about it (can be helpful for centralize logic of showing snack bars, etc). Rethrow the caught exception to handle it finally at the WidgetModel level.</p> <pre><code>class CountryListScreenModel extends ElementaryModel {\n  final ICountryRepository _countryRepository;\n\n  CountryListScreenModel(\n    this._countryRepository,\n    ErrorHandler errorHandler,\n  ) : super(errorHandler: errorHandler);\n\n  Future&lt;List&lt;Country&gt;&gt; loadCountries() async {\n    try {\n      final res = await _countryRepository.loadAllCountries();\n      return res;\n    } on Exception catch (e) {\n      handleError(e);\n      rethrow;\n    }\n  }\n}\n</code></pre>"},{"location":"tutorials/qs/implementation/#widgetmodel","title":"WidgetModel:","text":"<p>Open the created file to WidgetModel and implement all presentation logic and connect it with ElementaryModel.</p> <p>As a sample, we will take a widget model that simply loads data using the model on start, and shows a snack bar in case of connectivity issues. For managing the state of the loading list of countries we will use a publisher, provided by <code>elementary_helper</code> package. We create a private field inside the WidgetModel to store and manage this state and provide access via the <code>countryListState</code> getter. At start, use the <code>initWidgetModel</code> lifecycle method to initiate loading without waiting for the result. The <code>_loadCountryList</code> set the state of this data to loading, and call to the model for get data, waiting for result. If the loading finishes successfully, we set a content status for <code>countryListState</code> by providing the loaded data. If the loading finishes with an error, we set an error status for <code>countryListState</code> by providing information about the error. Every time when the model calls <code>handleError</code> the <code>onErrorHandle</code> calls. If error that we get is related to connectivity problems, we show a snack bar.</p> <pre><code>class CountryListScreenWidgetModel\n    extends WidgetModel&lt;CountryListScreen, CountryListScreenModel&gt;\n    implements ICountryListWidgetModel {\n  final ScaffoldMessengerWrapper _scaffoldMessengerWrapper;\n\n  final _countryListState = EntityStateNotifier&lt;List&lt;Country&gt;&gt;();\n\n  @override\n  EntityValueListenable&lt;List&lt;Country&gt;&gt; get countryListState =&gt;\n      _countryListState;\n\n  CountryListScreenWidgetModel(\n    super.model,\n    this._scaffoldMessengerWrapper,\n  );\n\n  @override\n  void initWidgetModel() {\n    super.initWidgetModel();\n\n    unawaited(_loadCountryList());\n  }\n\n  @override\n  void dispose() {\n    _countryListState.dispose();\n\n    super.dispose();\n  }\n\n  @override\n  void onErrorHandle(Object error) {\n    super.onErrorHandle(error);\n\n    if (error is DioException &amp;&amp;\n        (error.type == DioExceptionType.connectionTimeout ||\n            error.type == DioExceptionType.receiveTimeout)) {\n      _scaffoldMessengerWrapper.showSnackBar(context, 'Connection troubles');\n    }\n  }\n\n  Future&lt;void&gt; _loadCountryList() async {\n    final previousData = _countryListState.value.data;\n    _countryListState.loading(previousData);\n\n    try {\n      final res = await model.loadCountries();\n      _countryListState.content(res);\n    } on Exception catch (e) {\n      _countryListState.error(e, previousData);\n    }\n  }\n}\n</code></pre>"},{"location":"tutorials/qs/implementation/#elementarywidget","title":"ElementaryWidget:","text":"<p>Open the created file to ElementaryWidget and describe what the user should see based on the state of the WidgetModel. This is the easiest part, just accurately describe the screen, wrapping parts of it with builders that should react to changes in status.</p> <pre><code>class CountryListScreen extends ElementaryWidget&lt;ICountryListWidgetModel&gt; {\n  const CountryListScreen({\n    Key? key,\n    WidgetModelFactory wmFactory = countryListScreenWidgetModelFactory,\n  }) : super(wmFactory, key: key);\n\n  @override\n  Widget build(ICountryListWidgetModel wm) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Country list'),\n      ),\n      body: EntityStateNotifierBuilder&lt;Iterable&lt;Country&gt;&gt;(\n        listenableEntityState: wm.countryListState,\n        loadingBuilder: (_, __) =&gt; const _LoadingWidget(),\n        errorBuilder: (_, __, ___) =&gt; const _ErrorWidget(),\n        builder: (_, countries) =&gt; _CountryList(\n          countries: countries,\n        ),\n      ),\n    );\n  }\n}\n</code></pre>"},{"location":"tutorials/qs/tests/","title":"Tests","text":"<p>Add tests for your implementation. Let's look at an example of how this can be done. As a sample we'll use impementation of ElementaryModel, WidgetModel and ElementaryWidget that were provided in 'Implementation' section.</p>"},{"location":"tutorials/qs/tests/#elementarymodel","title":"ElementaryModel","text":"<p>For testing this layer, you need to add unit tests. </p> <p>A few scenarios should be tested: repository was used to load data, and handling error during the loading.</p> <pre><code>void main() {\n  late CountryRepositoryMock countryRepositoryMock;\n  late CountryListScreenModel model;\n\n  setUp(() {\n    countryRepositoryMock = CountryRepositoryMock();\n    model = CountryListScreenModel(countryRepositoryMock);\n  });\n\n  group('CountryListScreenModel', () {\n    test('loadCountries should get countries from repository', () async {\n      when(() =&gt; countryRepositoryMock.loadAllCountries())\n          .thenAnswer((invocation) =&gt; Future.value([]));\n\n      await model.loadCountries();\n\n      verify(() =&gt; countryRepositoryMock.loadAllCountries()).called(1);\n    });\n\n    test('loadCountries should rethrow exception', () async {\n      final error = Exception('test');\n\n      when(() =&gt; countryRepositoryMock.loadAllCountries())\n          .thenAnswer((invocation) =&gt; Future.error(error));\n\n      await expectLater(() async =&gt; model.loadCountries(), throwsA(error));\n    });\n  });\n}\n</code></pre>"},{"location":"tutorials/qs/tests/#widgetmodel","title":"WidgetModel","text":"<p>For testing this layer, you need to use elementary_test package. We need to test loading process with various conditions, such as in-progress, error, and successful getting result. Also we need to test, showing a snack bar from the context of the WidgetModel.</p> <pre><code>void main() {\n  late _MockCountryListScreenModel model;\n  late _MockScaffoldMessengerWrapper scaffoldMessengerWrapper;\n  late CountryListScreenWidgetModel wm;\n\n  setUp(() async {\n    model = _MockCountryListScreenModel();\n    scaffoldMessengerWrapper = _MockScaffoldMessengerWrapper();\n    wm = CountryListScreenWidgetModel(model, scaffoldMessengerWrapper);\n  });\n\n  tearDown(() {\n    return wm.dispose();\n  });\n\n  CountryListScreenWidgetModel setUpWm() {\n    return wm;\n  }\n\n  group('CountryListScreenWidgetModel', () {\n    testWidgetModel&lt;CountryListScreenWidgetModel, CountryListScreen&gt;(\n      'countryListState should be in loading after initialization',\n      setUpWm,\n      (wm, tester, context) async {\n        final completer = Completer&lt;List&lt;Country&gt;&gt;();\n        when(() =&gt; model.loadCountries()).thenAnswer((_) =&gt; completer.future);\n\n        tester.init();\n\n        expect(wm.countryListState.value.isLoadingState, true);\n      },\n    );\n\n    testWidgetModel&lt;CountryListScreenWidgetModel, CountryListScreen&gt;(\n      'countryListState should be in error if loading failed',\n      setUpWm,\n      (wm, tester, context) async {\n        final testException = Exception('test error');\n        when(() =&gt; model.loadCountries()).thenAnswer(\n          (_) =&gt; Future.delayed(\n            const Duration(milliseconds: 1),\n            () =&gt; throw testException,\n          ),\n        );\n\n        tester.init();\n        await Future&lt;void&gt;.delayed(const Duration(milliseconds: 10));\n\n        expect(wm.countryListState.value.isErrorState, true);\n        expect(wm.countryListState.value.errorOrNull, testException);\n      },\n    );\n\n    testWidgetModel&lt;CountryListScreenWidgetModel, CountryListScreen&gt;(\n      'countryListState should provide loaded data',\n      setUpWm,\n      (wm, tester, context) async {\n        final country = Country(name: 'test', flag: 'test');\n        when(() =&gt; model.loadCountries()).thenAnswer(\n          (_) =&gt; Future.delayed(\n            const Duration(milliseconds: 1),\n            () =&gt; [country],\n          ),\n        );\n\n        tester.init();\n        await Future&lt;void&gt;.delayed(const Duration(milliseconds: 10));\n\n        expect(wm.countryListState.value.isLoadingState, false);\n        expect(wm.countryListState.value.isErrorState, false);\n        final providedData = wm.countryListState.value.data;\n        expect(providedData, isNotNull);\n        expect(providedData!.contains(country), true);\n      },\n    );\n\n    testWidgetModel&lt;CountryListScreenWidgetModel, CountryListScreen&gt;(\n      'should show snack when connection troubles',\n      setUpWm,\n      (wm, tester, context) async {\n        when(() =&gt; model.loadCountries()).thenAnswer((_) =&gt; Future.value([]));\n        when(() =&gt; scaffoldMessengerWrapper.showSnackBar(context, any()))\n            .thenReturn(null);\n\n        tester.init();\n        wm.onErrorHandle(\n          DioException(\n            requestOptions: RequestOptions(),\n            type: DioExceptionType.connectionTimeout,\n          ),\n        );\n\n        verify(\n          () =&gt; scaffoldMessengerWrapper.showSnackBar(\n              context, 'Connection troubles'),\n        );\n      },\n    );\n  });\n}\n</code></pre>"},{"location":"tutorials/qs/tests/#elementarywidget","title":"ElementaryWidget","text":"<p>For testing this layer, you can use widget or golden tests. Both ways are pretty similar, we'll demonstrate only widget tests. Since the ElementaryWidget just describes its subtree using other widgets, the simplest way is to test the result of build method, providing a mock widget model to it. You can also test the insertion of the widget itself into the tree, in which case specify a function in the wmFactory parameter that returns a mock of the widget model.</p> <p>For the widget we need to test possible states a user can see: loading, error, an empty content and a content with data.</p> <pre><code>void main() {\n  const widget = CountryListScreen();\n  final wrapper = materialAppWrapper();\n  final countries = [\n    Country(\n      flag: 'test-flag-url',\n      name: 'Test country',\n    ),\n  ];\n  late MockCountryListScreenWidgetModel wm;\n  late EntityValueListenableMock&lt;List&lt;Country&gt;&gt; countryListStateMock;\n\n  setUp(() {\n    countryListStateMock = EntityValueListenableMock&lt;List&lt;Country&gt;&gt;();\n\n    wm = MockCountryListScreenWidgetModel();\n    when(() =&gt; wm.countryListState).thenReturn(countryListStateMock);\n  });\n\n  group('CountryListScreen', () {\n    testWidgets(\n      'should show CircularProgressIndicator while loading',\n      (tester) async {\n        when(() =&gt; countryListStateMock.value).thenReturn(\n          EntityState.loading(),\n        );\n\n        await tester.pumpWidget(\n          wrapper(widget.build(wm)),\n        );\n\n        expect(find.byType(CircularProgressIndicator), findsOneWidget);\n      },\n    );\n\n    testWidgets(\n      'should show error message when error',\n      (tester) async {\n        when(() =&gt; countryListStateMock.value).thenReturn(\n          EntityState.error(),\n        );\n\n        await tester.pumpWidget(\n          wrapper(widget.build(wm)),\n        );\n\n        expect(find.text('Something went wrong'), findsOneWidget);\n      },\n    );\n\n    testWidgets(\n      'should show message when it is loaded empty',\n      (tester) async {\n        when(() =&gt; countryListStateMock.value).thenReturn(\n          EntityState.content(),\n        );\n\n        await tester.pumpWidget(\n          wrapper(widget.build(wm)),\n        );\n\n        expect(find.text('No countries fetched'), findsOneWidget);\n      },\n    );\n\n    testWidgets(\n      'should show content when it is loaded',\n      (tester) async {\n        when(() =&gt; countryListStateMock.value).thenReturn(\n          EntityState.content(countries),\n        );\n\n        await tester.pumpWidget(\n          wrapper(widget.build(wm)),\n        );\n\n        expect(find.text('Test country'), findsOneWidget);\n      },\n    );\n  });\n}\n</code></pre>"},{"location":"tutorials/qs/tooling/","title":"Choose tooling:","text":"<p>To make work with library more convenient and automate classes creation, boilerplate code, etc., you can use one of this tools, otherwise you have to do all dirty work manually:</p> <ul> <li>plugin for IntelliJ</li> <li>plugin for VSCode</li> <li>elementary brick</li> <li>elementary_cli</li> </ul> <p>Depends on your IDE and personal preferences choose one of the ways:</p> Plugin for IntelliJPlugin for VSCodeElementary brickElementary cli <p>Install plugin from Marketplace:</p> <p>1. Open settings and then select Plugins.</p> <p>2. Click the Marketplace tab and type 'Elementary' in the search field.</p> <p>3. To install the plugin, click Install and restart IntelliJ IDEA.</p> <p>Install Elementary extensions from Extension Marketplace:</p> <p>1. Bring up the Extensions view by clicking on the Extensions icon in    the Activity Bar on the side of VS Code or the View: Extensions command (\u21e7\u2318X).</p> <p>2. Type 'Elementary' in the search field.</p> <p>3. To install the plugin, click Install</p> <p>If you don't have Mason installed, you need to install it by running the command:</p> <pre><code>dart pub global activate mason_cli\n</code></pre> <p>The next step is to initialize Mason, run:</p> <p><pre><code>mason init\n</code></pre> Then install Elementary by running the command:</p> <p>Install locally <pre><code>mason add elementary\n</code></pre> Install globally</p> <pre><code>mason add -g elementary\n</code></pre> <p>To direct usage run</p> <p><pre><code>dart pub global activate elementary_cli  \n</code></pre> or</p> <pre><code>flutter pub global activate elementary_cli\n</code></pre> <p>To use elementary_cli as a library in the pubspec.yaml file add <pre><code>dependencies:\n    elementary_cli: $actual_version\n</code></pre></p> <p>or run:</p> <p>With Dart:</p> <pre><code>dart pub add elementary_cli\n</code></pre> <p>With Flutter:</p> <pre><code>flutter pub add elementary_cli\n</code></pre> <p>After this run:</p> <pre><code>flutter pub get\n</code></pre>"}]}